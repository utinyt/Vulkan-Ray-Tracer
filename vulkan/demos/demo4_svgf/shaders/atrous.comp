#version 450
//#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

/** src */
layout(binding = 0, rgba32f) uniform readonly image2D srcColor;
layout(binding = 1, r32f) uniform readonly image2D srcVariance;
layout(binding = 2, rgba32f) uniform readonly image2D currGBufferPosition;
layout(binding = 3, rgba32f) uniform readonly image2D currGBufferNormal;

/** dst */
layout(binding = 4, rgba32f) uniform writeonly image2D dstColor;
layout(binding = 5, r32f) uniform writeonly image2D dstVariance;
layout(binding = 6, rgba32f) uniform writeonly image2D colorHistory;

layout(push_constant) uniform PushConstant{
	float iteration;
	float sigmal;
	float sigman;
	float sigmap;
};

void main(){
	ivec2 sampleLoc = ivec2(gl_GlobalInvocationID.xy);

	//5x5 a-trous kernel
	float a[25] = {
		1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0,
		1.0/64.0, 1.0/16.0, 3.0/32.0, 1.0/16.0, 1.0/64.0,
		3.0/128.0, 3.0/32.0, 9.0/64.0, 3.0/32.0, 3.0/128.0,
		1.0/64.0, 1.0/16.0, 3.0/32.0, 1.0/16.0, 1.0/64.0,
		1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0
	};

	//3x3 gaussian kernel
	float g[9] = {
		1.0/16.0, 1.0/8.0, 1.0/16.0,
		1.0/8.0, 1.0/4.0, 1.0/8.0,
		1.0/16.0, 1.0/8.0, 1.0/16.0
	};

	int step = 1 << int(iteration);
	ivec2 res = imageSize(srcColor);

	/*
	* blur variance 
	*/
	float sum = 0;
	float sumw = 0;
	ivec2 offset[9] = {
		ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),
		ivec2(-1, 0), ivec2(0, 0), ivec2(1, 0),
		ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1)
	};
	for(int i = 0; i < 9; ++i){
		ivec2 loc = sampleLoc + offset[i];
		if(loc.x >= 0 && loc.x < res.x && loc.y >= 0 && loc.y < res.y){
			sum += g[i] * imageLoad(srcVariance, sampleLoc).x;
			sumw += g[i];
		}
	}
	float variance = max(sum / sumw, 0.0);

	/*
	* a-trous filter
	*/
	vec4 srcCol = imageLoad(srcColor, sampleLoc);
	float srcLuminance = 0.2126 * srcCol.x + 0.7152 * srcCol.y + 0.0722 * srcCol.z;
	vec3 srcPos = imageLoad(currGBufferPosition, sampleLoc).xyz;
	vec3 srcNormal = imageLoad(currGBufferNormal, sampleLoc).xyz;

	vec3 colSum = vec3(0.f);
	float varianceSum = 0;
	float weightSum = 0;
	float weightSquaredSum = 0;

	for(int i = -2; i <= 2; ++i){
		for(int j = -2; j <= 2; ++j){
			ivec2 neighborLoc = sampleLoc + step * ivec2(i, j);
			if(neighborLoc.x >= 0 && neighborLoc.x < res.x && neighborLoc.y >= 0 && neighborLoc.y < res.y){
				//get neighbot info
				vec3 neighborCol = imageLoad(srcColor, neighborLoc).xyz;
				float neighborLuminance = 0.2126 * neighborCol.x + 0.7152 * neighborCol.y + 0.0722 * neighborCol.z;
				vec3 neighborPos = imageLoad(currGBufferPosition, neighborLoc).xyz;
				vec3 neighborNormal = imageLoad(currGBufferNormal, neighborLoc).xyz;

				//edge stopping functions
				float wl = exp(-distance(srcLuminance, neighborLuminance) / (sqrt(variance) * sigmal + 0.00001f));
				float wn = min(1.f, exp(-distance(srcNormal, neighborNormal) / (sigman + 0.00001f)));
				float wp = min(1.f, exp(-distance(srcPos, neighborPos) / (sigmap + 0.000001f)));

				int k = (2 + i) + (2 + j) * 5;
				float weight = a[k] * wl * wn * wp;
				weightSum += weight;
				weightSquaredSum += weight * weight;
				colSum += weight * neighborCol;
				varianceSum += weight * weight * imageLoad(srcVariance, neighborLoc).x;
			}
		}
	}

	if(weightSum > 0.00001f){
		vec4 col = vec4(colSum / weightSum, 1.f);
		imageStore(dstColor, sampleLoc, col);
		imageStore(dstVariance, sampleLoc, vec4(varianceSum / weightSquaredSum, 0, 0, 0));
		if(iteration == 0){
			imageStore(colorHistory, sampleLoc, col);
		}
	}
	else{
		imageStore(dstColor, sampleLoc, srcCol);
		if(iteration == 0){
			imageStore(colorHistory, sampleLoc, srcCol);
		}
	}
}
